[{"categories":["music-theory"],"contents":"Intro Recently I've been listening to a 12tone video on YouTube about negative harmony, a concept recently popularized by musician Jacob Collier. On the related links I found a bunch of videos from this channel with \u0026ldquo;negative harmony\u0026rdquo; versions of many popular songs.\nThe change in sonority of those songs clearly indicated for me a change in the mode of the song, which kind of go against the grain of what I've been told about the action of those transformations. In this post I want to explore negative harmony as a transformation not only on chords but on scales, modes and melody.\nWhat is Negative Harmony anyway? There are many ways to understand negative harmony and I'm not going to pretend I'm able to give a full historical background. The video by the 12tone channel that I linked above does a much better job than I ever could. Here in this post I'm mainly interested in this as a transformation that can be applied to a particular set of notes, and that's how I'm going to describe and treat it.\nTo understand what's the transformation being applied, consider the circle of fifths. In the key of C, the negative harmony transformation consists in swapping notes along the axis that cut the circle in half between the C and G.\n  \\begin{tikzpicture}[auto,node distance=2.5cm, block/.style={color=black, align=center, minimum height=1cm, minimum width=1.5cm}, vec/.style={double,thick,color=purple!20}] \\def \\n {12} \\def \\radius {4 cm} \\def \\margin {7} \\def \\notes {-5/D$\\flat$, -4/A$\\flat$, -3/E$\\flat$, -2/B$\\flat$, -1/F, 0/C, 1/G, 2/D, 3/A, 4/E, 5/B, 6/F$\\sharp$} \\foreach \\s/\\key in \\notes { \\def \\start {360 * \\s / \\n + 15} \\def \\end {360 * (\\s - 1) / \\n + 15} \\node[block, circle] at ({90-\\start}:\\radius) (a\\s) {\\key}; \\draw[color=purple,vec] ({\\end+\\margin}:\\radius) arc ({\\end+\\margin}:{\\start-\\margin}:\\radius); } \\draw [thick,dashed,color=blue!30] (0, -\\radius) -- (0, \\radius); \\draw[latex-latex,color=red!50] (a0) to (a1); \\draw[latex-latex,color=red!50] (a2) to (a-1); \\draw[latex-latex,color=red!50] (a3) to (a-2); \\draw[latex-latex,color=red!50] (a4) to (a-3); \\draw[latex-latex,color=red!50] (a5) to (a-4); \\draw[latex-latex,color=red!50] (a6) to (a-5); \\end{tikzpicture}   The circle of fifths highlighting the negative harmony transformation in the key of C    The arrows above indicate the notes that are to be switched. So, to apply the negative harmony transformation in the key of C, one would change C for G, D for F, etc.\nParameterizing Negative Harmony One aspect that is not often discussed about this transformation is that it is actually a family of transformations parameterized by a key center. Note that the reflection axis chosen above is only one chosen from 12 possibilities. To highlight this, notice that in the diagram above the transformation in the key of C takes F to D. In the diagram below we have transformation in the key of A, showing that in this case it takes F to A♭.\n  \\begin{tikzpicture}[auto,node distance=2.5cm, block/.style={color=black, align=center, minimum height=1cm, minimum width=1.5cm}, vec/.style={double,thick,color=purple!20}] \\def \\n {12} \\def \\radius {4 cm} \\def \\margin {7} \\def \\notes {-5/B$\\flat$, -4/F, -3/C, -2/G, -1/D, 0/A, 1/E, 2/B, 3/F$\\sharp$, 4/D$\\flat$, 5/A$\\flat$, 6/E$\\flat$} \\foreach \\s/\\key in \\notes { \\def \\start {360 * \\s / \\n + 15} \\def \\end {360 * (\\s - 1) / \\n + 15} \\node[block, circle] at ({90-\\start}:\\radius) (a\\s) {\\key}; \\draw[color=purple,vec] ({\\end+\\margin}:\\radius) arc ({\\end+\\margin}:{\\start-\\margin}:\\radius); } \\draw [thick,dashed,color=blue!30] (0, -\\radius) -- (0, \\radius); \\draw[latex-latex,color=red!50] (a0) to (a1); \\draw[latex-latex,color=red!50] (a2) to (a-1); \\draw[latex-latex,color=red!50] (a3) to (a-2); \\draw[latex-latex,color=red!50] (a4) to (a-3); \\draw[latex-latex,color=red!50] (a5) to (a-4); \\draw[latex-latex,color=red!50] (a6) to (a-5); \\end{tikzpicture}   The circle of fifths highlighting the negative harmony transformation in the key of A    Transforming modes Typically negative harmony is discussed in the context of chords, with an expectation that transformed chords has similar functions (having \u0026ldquo;equivalent tonal gravity\u0026rdquo;). I want to discuss how this transformation behaves when considering melodic elements, scales and modes.\nTo start, let's check what happens when we transform the seven modes of the major scale. For example, let's apply the transformation over the major scale. As an ilustration, the sequence of notes [C, D, E, F, G, A, B] (the Ionian mode of C Major), transformed in the key of C, will result in [G, F, E♭, D, C, B♭, A♭].\nThis sequence can be interpreted in a lot of different ways. Harmonically it is typical to consider the following argument. If the original harmony is in the key of C major, than the I chord is C major triad (C, E, G). This triad transforms to (G, E♭, C), which is an inversion of the C minor triad. Since this would also fit the role of the I chord in the new harmony, this should be interpreted as transforming from a C major harmony to a C minor one.\nThat's a good argument, but if we focus on the melody, the note that would be treated as the focus and resting place of the melody in the original key would be C, which would turn into G in the new melody. So, we could interpret G as the root note of the transformed sequence, which would make it a G Phrygian melody.\nLet's take this second stance and see what happens with all modes. Under this interpretation this is how the modes transform:\n C Ionian transforms into G Phrygian. C Dorian trasforms into G Dorian. C Phrygian trasforms into G Ionian. C Lydian transforms into G Locrian. C Mixolydian trasforms into G Aelian. C Aeolian trasforms into G Mixolydian. C Locrian transforms into G Lydian.  Negative Harmony inverts brightness Finally, here's the neat and interesting pattern to notice: if we ignore the roots, the quality of the modes above is transforming up and down the Brightness Scale.\n  \\usetikzlibrary{shapes,arrows,positioning,automata} \\usetikzlibrary{matrix,arrows,decorations.pathmorphing} \\begin{tikzpicture}[auto,node distance=1.25cm, block/.style={rectangle, thick, fill=purple!20, align=center, minimum height=1cm, minimum width=2cm}, vec/.style={double,thick,color=purple!20}, connecto/.style={, =latex, shorten =2pt, shorten ] (-2, -4) -- (-2, 4) node[above,sloped,color=purple] at (-2.5, 4) {high brightness} node[midway,above,sloped,color=purple] at (-2.5, 0) {\\textbf{Brightness Scale}} node[below,sloped,color=purple] at (-2.5, -4) {low brightness}; \\draw[connecto] (lyd.east) to node[auto, swap] {} (loc.east); \\draw[connecto] (ion.east) to node[auto, swap] {} (phr.east); \\draw[connecto] (mix.east) to node[auto, swap] {} (aeo.east); \\draw[connecto,bend left=90] (dor.30) to node[auto, swap] {} (dor.330); \\end{tikzpicture}    The effect of the transformation is to reflect the qualities of the modes around the center of the brightness scale, inverting the value of the brightness for the mode in question (the brightest mode becomes the darkest, the second brightest becomes the second darkest, etc).\nSo what? Yes, this is just a simple neat symmetry I found. I intend to write more later on some other questions:\n What happens when you transform modes of other scales? Modes of the major scale are closed under this transformation. But this definitely won't happen always. What does it mean when it happens? What happens when you transform modes under the negative harmony centered in other keys? Is there a \u0026ldquo;right\u0026rdquo; key to use?  Stay tuned.\n","permalink":"https://rcalsaverini.github.io/blog/negative-harmony-inverts-brightness-modes/","tags":["Music Theory","Negative Harmony","Set Theory (Music)"],"title":"Negative Harmony inverts brightness of modes"},{"categories":["programming"],"contents":"I have on and off again tried to use mypy to type check my python code, but some shortcomings of Python's type annotation system really get in the way. This came now because I needed to write code involving trees that had to change the types of values stored on the nodes. This highlighted a few serious shortcomings for anyone that is accostumed to use stronger type systems.\nThe ugly syntax for function types is annoying but there are worse problems Yes, writing Callable[[Callable[[A], B], F[A]], F[B]] instead of (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b as in Haskell or (A =\u0026gt; B, F[A]) =\u0026gt; F[B] (or maybe the uncurried (A =\u0026gt; B) =\u0026gt; (F[A] =\u0026gt; F[B]) version) as in Scala is really annoying.\nBut that's neither here nor there. One can get accostumed to it. On the other hand, it is certainly symptomatic of the philosophy chosen for the type system: passing functions around is not an idea on the forefront of this design.\nPeople are not using it In general, the overwhelming majority of the python libraries I use simply don't have type annotations or stub files and don't plan to add them in the near future. Writing stub files on your own is a pain. This by itself prevents the adoption of type annotations without a lot of effort in providing stub files yourself.\nThe ad hoc polymorphism mechanism chosen is annoying The only way to do ad hoc polymorphism is with structural subtyping (using Protocol). This isn't so bad, since the language embraces duck typing so thoroughly. But it's somewhat annoying for two reasons:\n  First, admitedly a lesser problem, there's no clear indication in the code that a given class implements a particular Protocol. There's no explicit inheritance, nor explicit instancing of the Protocol. If you don't know the protocol exists, when you see the code of a class, you have no clue that there is a more general pattern that this class implements.\n  Second, there's no \u0026ldquo;post facto\u0026rdquo; instancing of Protocol like it's possible to do with Haskell's or Scala's typeclasses, or Go's interfaces. You have one chance to instanciate a class as a particular Protocol: when you write that classes code. If the class belongs to a third party library you can't change, you have to write wrappers (which are terribly annoying, because the language offers no syntax sugar for them).\n  No support for lightweight parametrically polymorphic product types Python's type annotations don't allow you to write generic named tuples. This prevents one to write very lightweight types like:\nclass Foo(NamedTuple, Generic[A]): a_value: A a_list: List[A] If you want a parametrically polymorphic type, it must be a fully fledged class by itself.\n### will type check class Foo(Generic[A]): def __init__(self, a_value: A, a_list: List[A]): self.a_value = a_value self.a_list = a_list This discourages me to use it for many applications, since Python's classes are not exactly lightweight things and I'd rather not have a class if I don't really need one. You could use a type synonym for an untagged tuple, but this would be a serious documentation hazard:\nFoo = Tuple[A, List[A]] No support for lightweight recursive product types Similarly, Python's type annotations don't allow recursive types unless you're dealing with a full fledged class. Recursive NamedTuples are forbidden, and so are recursive Unions (which wouldn't be possible given the restriction on higher-kinded types anyway, see below). This further prevents fast and lightweight types like:\nclass BinaryTree(NamedTuple): left: \u0026#34;BinaryTree\u0026#34; right: \u0026#34;BinaryTree\u0026#34; and requires you to use the full (and heavy) Python classes:\nclass BinaryTree(object): def __init__(self, left: \u0026#34;BinaryTree\u0026#34;, right: \u0026#34;BinaryTree\u0026#34;): self.left = left self.right = right No higher kinded types Python's type annotations have no support for higher-kinded types. All type variables in a class that inherit from Generic must be of kind *. This is kind of a catastrophe for any kind of more advanced use of the type system to improve correctness garantees. It also prevents some uses of higher kinded patterns like functors, monads, etc.\nFor example, you can't use the finally tagless or tagless-final pattern. At least not like this:\nclass DataAccessMonad(Generic[M]): def get_user(self, user_id: UserId) -\u0026gt; M[User] pass Also, this makes it difficult to implement \u0026ldquo;post-facto\u0026rdquo; ad hoc polymorphism using something like Scala's typeclass instance mechanisms to escape Protocols. For this, one would need to write:\nclass FunctorInstance(Generic[F]): @staticmethod def map(value: F[A], function: Callable[[A], B]) -\u0026gt; F[B]: pass My original plan for a type class library involved creating a way to inject the instance, wrap the F[A] value and monkey patch it to call value.map when you need it. The fact that one can't use higher kinded types prevents the code above to type check.\nAnd so\u0026hellip; no fixed point functors and other niceties This means also that you can't use fixed point types like:\nclass CoFree(NamedTuple, Generic[F, A]): value: A continuations: F[\u0026#34;Cofree[F, A]\u0026#34;] because this requires F to be of kind * -\u0026gt; *. Fixed point types are awfully useful for dealing with tree-like structures (see for example this talk from Rob Norris) and would similarly fail to type check on mypy.\nConclusion There are more problems, but those are the main ones that prevented me from really using mypy or type annotations in Python. This haven't prevented me from writing good and useful Python code, and I still love to write Python. But it certainly increases the attrition.\n","permalink":"https://rcalsaverini.github.io/blog/2019-01-20-frustrations-with-mypy/","tags":["Python","Type safety","Mypy"],"title":"A few frustrations with Python's type annotation system"},{"categories":["programming"],"contents":"I've been recently trying to learn more advanced type-level constructs in Haskell and was very happy to find this amazing talk by Prof. Stephanie Weirich about Dependent Types in haskell. This talk helped me to understand deeper a few more recent concepts introduced by some of GHC's extensions and how to use them. In this post I want to focus a little bit in a simplified version of one of the data structures Prof. Weirich uses in her talk. She does a lot more than this, in the talk, but I'm going slowly to understand every bit of it.\nType Safe Records The record problem is an old problem in Haskell. Succintly, Haskell's traditional native records have lots of problems \u0026ndash; you couldn't reuse record names, updating record fields lead to dull boilerplate code, etc. Many of those problems are attacked by the idea of lenses (see this talk by Simon Peyton Jones to get the basics of it) and many other libraries as well as the OverloadedRecordFields extension.\nThough there are many solutions attacking parts of the record problem, there's one particular aspect of it which offers a nice opportunity to learn type level programming techniques in Haskel and are worth working out from scratch: how to create records whose type's are aware of the fields contained in the records and their types?\nThat means, how to create a record type such that the when we try to access a non-existing field:\n\u0026gt; getField \u0026#34;nonExistentFieldName\u0026#34; record we get an actual type error in compile time. This allows us to completely rule out a whole class of bugs from our programs: we don't need to worry about users acessing unexisting fields type of errors because this code wouldn't even compile.\nFirst attempt: a list of named entries Our first attempt will be to model our records as lists of named-entries:\ndata Entry a = Entry String a data Dict a = Nil | Cons (Entry a) (Dict a) getField :: String -\u0026gt; Dict a -\u0026gt; Maybe a getField _ Nil = Nothing getField name (Cons (Entry name\u0026#39; x) dict\u0026#39;) = case (name == name\u0026#39;) of True -\u0026gt; Just x False -\u0026gt; getField name dict\u0026#39; This compiles alright, but it's not a solution to our problem. First of all, it has no information about the entry field names in the type. The type of Dict a only carries information about the type of the values. Second, all fields must be of the same type. If you try to build something like: '\u0026rsquo;\n-- this raises a type error myRecord = Cons (Entry \u0026#34;name\u0026#34; \u0026#34;Rafael\u0026#34;) (Cons (Entry \u0026#34;age\u0026#34; (35::Int)) Nil) You'll get an obvious type error since Cons (Entry \u0026quot;age\u0026quot; 35::Int) Nil is a Dict Int and Entry \u0026quot;name\u0026quot; \u0026quot;Rafael\u0026quot; is an Entry String, and Cons type signature is Entry a -\u0026gt; Dict a -\u0026gt; Dict a.\nSo, it seems that this is not a very useful record (:P).\nLet's try to solve the second problem first and make the type of each entry more flexible. For that we need GADTs and existential types.\nUsing GADTs and existential types The second problem is caused by the fact the we have a explicit reference to the type of the entry in the Dict type constructor. We could try to make it more flexible like this:\ndata Dict a = Nil | Cons (Entry a) (Dict b) But of course this doesn't work because the type variable b is not defined in this scope. There is no way for the type checker to fix it:\n/.../Post.hs:5:42: error: Not in scope: type variable ‘b’ | 5 | data Dict a = Nil | Cons (Entry a) (Dict b) For this to work, we need to put b in scope, without adding it as argument to the type constructor or else we'd get an infinite regress of types (I'll get back to this later). For that we need two GHC extensions: GADTs and Rank2Types (or RankNTypes, or other extension providing the forall keyword).\nGADTs is an extension that allows us to give more generic types to the data constructors of an algebraic data type. It also allows a nicer syntax for data constructors with a long type signature. With GADTs and RankNTypes enabled we can do this:\n{-# LANGUAGE GADTs, RankNTypes #-} data Entry a = Entry String a data Dict a = Nil | forall b . Cons (Entry a) (Dict b) This compiles correctly and we can try to use it! Now our previous record is well typed:\nmyRecord :: Dict String myRecord = Cons (Entry \u0026#34;name\u0026#34; \u0026#34;Rafael\u0026#34;) (Cons (Entry \u0026#34;age\u0026#34; (35::Int)) Nil) But look what happened. The information that there's an Int somewhere inside the structure of the record is gone! Yep. We enclosed it in a forall and all the information Cons have now is that its second argument is some kind of Dict b, whatever b is. This doesn't look like a good sign.\nLet's try to write a getField function. We still didn't solve the problem of letting the type know what fields are possible, so we still need to guard ourselves against the possibility that the user will try to fetch the data from a field that doesn't exist. So the signature of getField still is String -\u0026gt; Dict a -\u0026gt; Maybe\u0026hellip; wait a minute! What's the return type?\nIn the record above, if the field name is \u0026quot;name\u0026quot; it should return a String, but if the field name is \u0026quot;age\u0026quot; it should return an Int. But the compiler wouldn't know that because there's no information in the type of the record about the value of the fields in is tail. We only have information about the type of the head entry.\nSo, the return type of getField is something like (forall b . Maybe b)? That doesn't look very useful. I can retrieve the value but I loose all the information about its type! This doesn't seem to be working\u0026hellip;\nKeeping track of the field types I want to get back to \u0026ldquo;infinite regress of types\u0026rdquo; I refered above. Why couldn't we put the b type variable above as an argument for the type constructor? Well, let's try and see. We could create a data type Dict a b where a is the value of the head Entry and b is the type of the head of the next Dict down the Cons data constructor. So:\ndata Dict a b = Nil | Cons (Entry a) (Dict b ???) Oops. Damn, what about the type of the entry after the next entry? Well\u0026hellip; Let's put it in the constructor too:\ndata Dict a b c = Nil | Cons (Entry a) (Dict b c ???) You get it, right? There's always a new type to keep track of. The type of the record must know not only the type of the head entry, but also all the types of all entries in its tail. This looks a hell like a linked list of types, doesn't it? If we had a way to create a type level list we could have the following GADT:\ndata Dict (types :: (TypeLevelList Type)) where Nil :: Dict TypeLevelEmptyList Cons :: (Entry a) -\u0026gt; Dict (tail :: TypeLevelList) -\u0026gt; Dict (a `TypeLevelCons` tail) Wait, what the hell is this? First of all, what are those type signatures in the wrong place? Those are kind signatures. Kind is the \u0026ldquo;type of a type constructor\u0026rdquo;. For example, type constructors that have no parameters, like Bool or String have kind Type (or *). Type constructors that take a single parameter, like Maybe have kind Type -\u0026gt; Type. Single parameter Typeclasses like Functor or Monad have kind Type -\u0026gt; Constraint, etc.\nHere I'm supposing that there exists a kind called TypeLevelList, and that there exists two type constructors:\n TypeLevelEmptyList with kind TypeLevelList, TypeLevelCons with kind Type -\u0026gt; TypeLevelList -\u0026gt; TypeLevelList.  When I write data Dict (types :: TypeLevelList) I'm declaring a type constructor Dictwith kind TypeLevelList -\u0026gt; Type. This type has two data constructors:\n Nil which is just an empty record with type Dict TypeLevelEmptyList Cons which takes an Entry a and a Dict TypeLevelList and return another Dict TypeLevelList putting a on the head of that TypeLevelList it received.  In practice we'd have something like this:\nemptyRecord :: Dict TypeLevelEmptyList emptyRecord = Nil agedRecord :: Dict (Int `TypeLevelCons` TypeLevelEmptyList) agedRecord = Cons (Entry \u0026#34;age\u0026#34; 35) emptyRecord recordWithAStringAndAnInt :: Dict (String `TypeLevelCons` Int `TypeLevelCons` TypeLevelEmptyList) namedAndAgedRecord = Cons (Entry \u0026#34;name\u0026#34; \u0026#34;Rafael\u0026#34;) agedRecord This is sweet! We can keep track to the types of all fields! But how do we create those type level lists? :O\nType Level Lists To create those type level lists we have to use a GHC extension called DataKinds. To understand what DataKinds do lets consider this simple type declaration:\ndata Nat = Zero | Succ Nat What this does is to create a type constructor called Nat, whose kind is Type, and two data constructors:\n Zero, whose type is Nat Succ, whose type is Nat -\u0026gt; Nat  When you use the DataKinds extension this declaration creates, besides the three objects described above, three more objects:\n a \u0026ldquo;kind constructor\u0026rdquo; 'Nat (the tick is not a typo) a type constructor 'Zero whose kind is 'Nat a type constructor 'Succ whose kind is 'Nat -\u0026gt; 'Nat  Those types constructed with those type constructors are not inhabited by values, but they are very useful for type computation. So, how do we create the \u0026ldquo;kind constructor\u0026rdquo; TypeLevelList with type constructor TypeLevelEmptyList and TypeLevelCons? Exactly with the same code that we would use to create a type constructor List with data constructor EmptyList and Cons, but we use the DataKinds extension to lift those objects from the value :: type world to the type :: kind world. We can do:\n{-# LANGUAGE GADTs, RankNTypes, DataKinds, KindSignatures #-} module Post where import Data.Kind (Type) data Entry a = Entry String a data List a = EmptyList | ListCons a (List a) data Dict (a :: (List Type)) where Nil :: Dict \u0026#39;EmptyList Cons :: Entry a -\u0026gt; Dict t -\u0026gt; Dict (\u0026#39;ListCons a t) So, what's happening here? First of all we have the declaration data List a = EmptyList | ListCons a (List a). This is a simple list type, but since we used the Data.Kinds extension, we get a new list kind for free:\n 'List is a \u0026ldquo;kind constructor\u0026rdquo; which takes a kind and return another kind (* -\u0026gt; *) 'EmptyList :: forall a . List a is a type constructor 'ListCons :: forall a . a -\u0026gt; List a -\u0026gt; List a is another type constructor  So, when applied to the kind Type, the \u0026ldquo;kind constructor\u0026rdquo; 'List creates the kind 'List Type which is a list of types! We can have the following types which have this kind:\n\u0026#39;EmptyList \u0026#39;ListCons Int \u0026#39;EmptyList \u0026#39;ListCons String (Cons Int \u0026#39;EmptyList) etc. All those types have kind 'List Type. Those types are not inhabited (that is, we can't construct values that have those types), but we can used them to provide compile time information that helps us to avoid bugs, because we can build type constructors that build inhabited types out of them! For example, we can build Dict. Let's check the kind of Dict on GHCi:\n\u0026gt; :k Dict Dict :: List Type -\u0026gt; Type -- the actual GHCi output is Dict :: List * -\u0026gt; *, but Type is a nice synonym for * This is what's happening with the declaration data Dict (a :: (List Type)). We used the extension KindSignatures to inform the compiler that the Dict type constructor has a kind which takes an argument of kind List Type and returns a regular Type.\nNow to the data constructors - which are the things that allows us to actually build values of type Dict a. The simples one is Nil which builds a value of type Dict 'EmptyList. This is an empty record, with no values stored and thus no types stored in the type level list.\nAlso we have Cons, which takes a parameter of type Entry a and a parameter of type Dict t (remember, here t is a type of kind 'List Type) and builds a value of type Dict ('ListCons a t). So, Cons does two things:\n it concatenates a new entry with an existing record, it also concatenates the type of the value stored in this entry into an existing list of types that describes the types of the entries in the existing record.  Wow. If that's too much to grasp, let's see this in action:\nnamedRecord ::Dict (\u0026#39;ListCons String \u0026#39;EmptyList) namedRecord = (Entry \u0026#34;name\u0026#34; \u0026#34;Rafael\u0026#34;) Nil namedAndAgedRecord :: Dict (\u0026#39;ListCons Int (\u0026#39;ListCons String \u0026#39;EmptyList)) namedAndAgedRecord = Cons (Entry \u0026#34;age\u0026#34; (35::Int)) namedRecord See how the types of the fields we're creating are concatenated in the type of the record? This allows us to know precisely the types of all the fields in a record!\nMaking it prettier We didn't have to code our own list type, Haskell already provides one for us and fortunately Data.Kinds works with the built-in types too. So we could have written simply:\n{-# LANGUAGE GADTs, RankNTypes, DataKinds, KindSignatures, TypeInType, TypeOperators #-} module Post where import Data.Kind (Type) infixr 6 :\u0026gt; data Entry a = Entry String a data Dict (a :: [Type]) where Nil :: Dict \u0026#39;[] (:\u0026gt;) :: Entry a -\u0026gt; Dict t -\u0026gt; Dict (a:t) We made a few changes to make the types nicer:\n  We are now using Haskel's built-in lists:\n\u0026gt; :k Dict Dict :: [Type] -\u0026gt; Type This is completely equivalent to the previous signature List Type -\u0026gt; Type the only difference is that we're using the built-in type instead of our custom list type.\n  We're using the TypeInType extension to allow for the syntax [Type]\n  We're using the TypeOperators extension to allow for two things:\n using the promoted type constructor (:) :: a -\u0026gt; [a] -\u0026gt; [a] which concatenates a type on the head of a type level list; renaming the ugly Cons data constructor to a nicer (:\u0026gt;) infix type operator so that the expressions are nicer looking.    With this modifications, instead of this ugly monster:\nmyRecord :: Dict (\u0026#39;ListCons String (\u0026#39;ListCons Int \u0026#39;EmptyList)) myRecord = Cons (Entry \u0026#34;name\u0026#34; \u0026#34;Rafael\u0026#34;) (Cons (Entry \u0026#34;age\u0026#34; 35) Nil) we can write this:\nmyRecord :: Dict \u0026#39;[String, Int] myRecord = Entry \u0026#34;name\u0026#34; \u0026#34;Rafael\u0026#34; :\u0026gt; Entry \u0026#34;age\u0026#34; 35 :\u0026gt; Nil Much better, right?\nThis is already too long and you didn't get to the point you promised Well, yep. This post is already big and we still don't know:\n how to write getField how to enhance the type Dict to allow for information about field names to be statically checked by the compiler.  So it looks like a perfect point to stop and start planning to write Part 2!\n","permalink":"https://rcalsaverini.github.io/blog/2018-02-12-type-safe-records/","tags":["Haskell","Type safety","Records","Type-level programming"],"title":"Type safe records as an excuse to learn type level programming in Haskell"},{"categories":null,"contents":"","permalink":"https://rcalsaverini.github.io/publications/2016-hierarchy/","tags":null,"title":"Phase transition from egalitarian to hierarchical societies driven by competition between cognitive and social constraints"},{"categories":null,"contents":"","permalink":"https://rcalsaverini.github.io/publications/2013-phd/","tags":null,"title":"Tópicos em mecânica estatística de sistemas complexos: uma abordagem mecânico-estatística de dois tópicos de interesse em finanças, economia e sociologia"},{"categories":["programming"],"contents":"Disclaimer: this is an old blog post from a very old wordpress blog and may contain inacuracies. I reproduced it as is for sentimental reasons. I may revisit this theme later.\nWhile randomly browsing around on Planet Haskell I've found a post on Heinrich Apfelmus\u0026rsquo; blog about something called \u0026ldquo;operational semantics\u0026rdquo; for monads. Found it very iluminating. Basically it's a form to implement monads focusing not on defining the bind and return operators, but on what the monad is really supposed to do. It's a view where a monad define a Domain Specific Language, that must be interpreted in order to cause it's effects. It seems to me it's exactly what is implemented in the monadprompt (Control.Monad.Prompt) package, although I'm not sure.\nThe Operational Monad {-# LANGUAGE GADTs #-} import Control.Monad import Data.Map (Map, fromList, unionWith) The definition of a monad on this approach starts with a common interface given by the following data type and a singleton function:\ndata Program m a where Then :: m a -\u0026gt; (a -\u0026gt; Program m b) -\u0026gt; Program m b Return :: a -\u0026gt; Program m a singleton :: m a -\u0026gt; Program m a singleton i = i `Then` Return Note that the types of the data constructors Then and Return are very similar (but not equal\u0026hellip;) to the types of the monadic operations (\u0026raquo;=) and return. This identification of class functions with data constructors is recurring throughout this post. This data type is instanciated as a traditional monad as follows:\ninstance Monad (Program m) where return = Return (Return a) \u0026gt;\u0026gt;= f = f a (i `Then` is) \u0026gt;\u0026gt;= f = i `Then` (\\ x -\u0026gt; is x \u0026gt;\u0026gt;= f) This is all we need! As an example let's describe the implementation of the State Monad within this approach. This is exactly the first example given by Apfelmus on his post, disguised as a stack machine.\nExample: implementing the State Monad The operational approach to monads begins with recognizing what operations you want your monad to perform. A State Monad have a state, a return value and two function: one that allows us to retrieve the state as the return value, and one that allows us to insert a new state. Let's represent this in the following GADT:\ndata StateOp st retVal where Get :: StateOp st st -- retrieve current state as a returned value Put :: st -\u0026gt; StateOp st () -- insert a new state This are the operations needed on the State Monad, but the monad itself is a sequence of compositions of such operations:\ntype State st retVal = Program (StateOp st) retVal Note that the type synonym State st is a monad already and satisfy all the monad laws by construction. We don't need to worry about implementing return and (\u0026gt;\u0026gt;=) correctly: they are already defined.\nSo far, so good but\u0026hellip; how do we use this monad in practice? This types define a kind of Domain Specific Language: we have operations represented by Get and Put and we can compose them in little programs by using Then and Return. Now we need to write an interpreter for this language. I find this is greatly simplified if you notice that the construct\ndo x \u0026lt;- singleton foo bar x can be translated as foo Then bar in this context. Thus, to define how you'll interpret the later, just think what's the effect you want to have when you write the former.\nOur interpreter will take a State st retVal and a state st as input and return a pair: the next state and the returned value (st, retVal):\ninterpret :: State st retVal -\u0026gt; st -\u0026gt; (st, retVal) First of all, how should we interpret the program Return val ? This program just takes any state input and return it unaltered, with val as it's returned value:\ninterpret (Return val) st = (st, val) The next step is to interpret the program foo Then bar. Looking at the type of things always helps: Then, in this context, have type StateOp st a -\u0026gt; (a -\u0026gt; State st b) -\u0026gt; State st b. So, in the expression foo Then bar, foo is of type StateOp st a, that is, it's a stateful computation with state of type st and returned value of type a. The rest of the expression, bar, is of type a -\u0026gt; State st b, that is, it expects to receive something of the type of the returned value of foo and return the next computation to be executed. We have two options for foo: Get and Put x.\nWhen executing Get Then bar, we want this program to return the current state as the returned value. But we also want it to call the execution of bar val, the rest of the code. And if val is the value returned by the last computation, Get, it must be the current state:\ninterpret (Get `Then` bar) st = interpret (bar st) st The program Put x Then bar is suposed to just insert x as the new state and call bar val. But if you look at the type of Put x, it's returned value is empty: (). So we must call bar (). The current state is then discarded and substituted by x.\ninterpret (Put x `Then` bar) _ = interpret (bar ()) x We have our interpreter (which, you guessed right, is just the function runState from `Control.Monad.State) and now it's time to write programs in this language. Let's then define some helper functions:\nget :: State st st get = singleton Get put :: st -\u0026gt; State st () put = singleton . Put and write some code to be interpreted:\nexample :: Num a =\u0026gt; State a a example = do x \u0026lt;- get put (x + 1) return x test1 = interpret example 0 test2 = interpret (replicateM 10 example) 0 This can be run in ghci to give exactly what you would expect from the state monad:\n*Main\u0026gt; test1 (1,0) *Main\u0026gt; test2 (10,[0,1,2,3,4,5,6,7,8,9]) Vector Spaces The approach seems very convenient from the point of view of developing applications, as it's focused on what are actions the code must implement and how the code should be executed. But it seems to me that the focus on the operations the monad will implement is also very convenient to think about mathematical structures. To give an example, I'd like to implement a monad for Vector Spaces, in the spirit of Dan Piponi (Sigfpe)\u0026lsquo;s ideas here, here and here.\nA vector space $\\mathbb{V_F}$ is a set of elements $\\mathbf{x}\\in\\mathbb{V_F}$ that can be summed ($\\mathbf{x} + \\mathbf{y} \\in\\mathbb{V_F}$ if $\\mathbf{x},\\mathbf{y} \\in \\mathbb{V_F}$) and multiplied elements of a field ($\\alpha\\mathbf{x}$ if $\\alpha\\in \\mathcal{F}$ and $\\mathbf{x}\\in\\mathbb{V_F}$). If we want this to be implemented as a monad then, we should, in analogy with what we did for the State Monad, write a GADT with data constructors that implement the sum and product by a scalar:\ndata VectorOp field label where Sum :: Vector field label -\u0026gt; Vector field label -\u0026gt; VectorOp field label Mul :: field -\u0026gt; Vector field label -\u0026gt; VectorOp field label type Vector field label = Program (VectorOp field) label and then we must implement a interpreter:\nrunVector :: (Num field, Ord label) =\u0026gt; Vector field label -\u0026gt; Map label field runVector (Return a) = fromList [(a, 1)] runVector (Sum u v `Then` foo) = let uVec = (runVector (u \u0026gt;\u0026gt;= foo)) vVec = (runVector (v \u0026gt;\u0026gt;= foo)) in unionWith (+) uVec vVec runVector (Mul x u `Then` foo) = fmap (x*) (runVector (u \u0026gt;\u0026gt;= foo)) The interpreter runVector takes a vector and returns it's representation as a Map. As an example, we could do the following:\ninfixr 3 \u0026lt;*\u0026gt; infixr 2 \u0026lt;+\u0026gt; u \u0026lt;+\u0026gt; v = singleton $ Sum u v x \u0026lt;*\u0026gt; u = singleton $ Mul x u data Base = X | Y | Z deriving(Ord, Eq, Show) x, y, z :: Vector Double Base x = return X y = return Y z = return Z reflectXY :: Vector Double Base -\u0026gt; Vector Double Base reflectXY vecU = do cp \u0026lt;- vecU return (transf cp) where transf X = Y transf Y = X transf Z = Z and test this on ghci:\n*Main\u0026gt; runVector $ x \u0026lt;+\u0026gt; y fromList [(X,1.0),(Y,1.0)] *Main\u0026gt; runVector $ reflectXY $ x \u0026lt;+\u0026gt; z fromList [(Y,1.0),(Z,1.0)] As Dan Piponi points out in his talk, any function acting on the base f :: Base -\u0026gt; Base is lifted to a linear map on the vector space Space field Base by doing (because this is the Free Vector Space over Base):\nlinearTrans f u = do vec \u0026lt;- u return (f vec) More on this later. :)\n","permalink":"https://rcalsaverini.github.io/blog/2010-08-25-operational-semantics/","tags":["Haskell","Monads","Operational Monads","Free Monads","Free Vector Space","Category Theory"],"title":"Operational Semantics for Monads"},{"categories":["programming"],"contents":"Disclaimer: this is an old blog post from a very old wordpress blog and may contain inacuracies. I reproduced it as is for sentimental reasons. I may revisit this theme later.\nI have a difficulty to understand functional programming concepts that I can’t put to some very simple and natural use (natural for me, of course). I need to find the perfect simple example to implement to finally understand something. And I’m not a computer scientist, so things like parsers and compilers have very little appeal to me (probably because I don’t understand them…). I’m a physicist, so this drives me to look for physical problems that can be implemented in Haskell so I can understand some concepts.\nMonad transformers still eludes me. But I think I finally got the perfect subject were I can understand them: stochastic processes! First some book keeping:\nimport Control.Monad.State import Control.Monad import Control.Monad.Rand Now, stochastic processes have characteristics related to two different monads. In one hand, they are dynamical processes, and the way to implement dynamics in Haskell is with state monads. For example, if I want to iterate the logistic map:\n$$x_{t+1} = \\alpha x_t\\left(1-x_t\\right)$$\n$$ teste = teste $$\nI could do the following:\nf :: Double -\u0026gt; Double f x = 4*x*(1-x) logistic :: State Double Double logistic = do x0 \u0026lt;- get let x1 = f x put x1 return x1 runLogistic :: State Double [Double] runLogistic n x0= evalState (replicateM n logistic) x0 Running this on ghci would give you, for example:\n*Main\u0026gt; runLogistic 5 0.2 [0.6400000000000001,0.9215999999999999,0.28901376000000045, 0.8219392261226504,0.5854205387341] So we can make the loose correspondence: dynamical system ↔ state monad.\nOn the other hand, stochastic processes are compositions of random variables, and this is done with the Rand monad (found in Control.Monad.Random). As an example, the Box-Muller formula tells us that, if I have two inpendent random variables $x$ and $y$, distributed uniformly between in the \\([0, 1]\\) interval, then, the expression:\n$$\\sqrt{-2\\log(x)}\\cos(2\\pi y)$$\nwill be normally distributed. We can write then:\nboxmuller :: Double -\u0026gt; Double -\u0026gt; Double boxmuller x y = sqrt(-2*log x)*cos(2*pi*y) normal :: Rand StdGen Double -- normally distributed normal = do x \u0026lt;- getRandom y \u0026lt;- getRandom return $ boxmuller x y normals n = replicateM n normal -- n independent samples from normal Running this function we get what we need:\n*Main\u0026gt; (evalRand $ normals 5) (mkStdGen 0) = [0.1600255836730147,0.1575360140445035,-1.595627933129274, -0.18196791439834512,-1.082222285056746] So what is a stochastic process? In very rough terms: is a dynamical system with random variables. So we need a way to make the Rand monad to talk nicely with the State monad. The way to do this is to use a monad transformer, in this case, the StateT transformer. Monad transformers allows you to combine the functionalities of two different monads. In the case of the StateT monads, they allow you to add a state to any other monad you want. In our case, we want to wrap the Rand monad inside a StateT transformer and work with things of type:\nfoo :: StateT s (Rand StdGen) r This type represent a monad that can store a state with type s, like the state monad, and can generate random variables of type r, like the rand monad. In general we would have a type\nfoo2 ::(MonadTrans t, Monad m) =\u0026gt; t m a In this case, t = StateT s and m = Rand StdGen. The class MonadTrans is defined in Control.Monad.Trans, and provides the function:\nlift :: (MonadTrans t, Monad m) =\u0026gt; m a -\u0026gt; t m a In this case, t is itself a monad, and can be treated like one through the code. It works like this: inside a do expression you can use the lift function to access the inner monad. Things called with lift will operate in the inner monad. Things called without lift will operate in the outer monad.\nSo, suppose we want to simulate this very simple process:\n$$x_{t+1} = x_t + \\eta_t$$\nwhere \\(\\eta_t\\) is drawn from a normal distribution. We would do:\nrandomWalk :: StateT Double (Rand StdGen) Double randomWalk = do eta \u0026lt;- lift normal x \u0026lt;- get let x\u0026#39; = x + eta put x\u0026#39; return x\u0026#39; runWalk :: Int -\u0026gt; Double -\u0026gt; StdGen -\u0026gt; [Double] runWalk n x0 gen = evalRand (replicateM n $ evalStateT randomWalk x0) gen The evalStateT function is just evalState adapted to run a StateT monad. Running this on ghci we get:\n*Main\u0026gt; runWalk 5 0.0 gen [0.1600255836730147,0.1575360140445035,-1.595627933129274, -0.18196791439834512,-1.082222285056746] This is what we can accomplish: we can easily operate simultaneously with functions that expect a state monad, like put and get, we can unwrap things with \u0026lt;- from the inner Rand monad by using lift , and we can return things to the state monad. We could have any monad inside the StateT transformer. For example, we could have another State monad. Here is a fancy implementation of the Fibonacci sequence using a State monad (that stores the last but one value in the sequence as its internal state) inside a StateT transfomer (that stores the last value of the sequence):\nfancyFib :: StateT Int (State Int) Int fancyFib = do old \u0026lt;- lift get new \u0026lt;- get let new\u0026#39; = new + old old\u0026#39; = new lift $ put old\u0026#39; put new\u0026#39; return new fancyFibs :: Int -\u0026gt; StateT Int (State Int) [Int] fancyFibs n = replicateM n fancyFibs And we can run this to get:\n*Main\u0026gt; evalState (evalStateT (fancyFibs 10) 1) 0 [1,1,2,3,5,8,13,21,34,55] ","permalink":"https://rcalsaverini.github.io/blog/2010-08-03-stochastic-processes/","tags":["Haskell","Monad Transformers","Monads","Stochastic Processes","Probability Monad"],"title":"Stochastic Processes as Monad Transformers"},{"categories":null,"contents":"","permalink":"https://rcalsaverini.github.io/publications/2009-copula/","tags":null,"title":"An information-theoretic approach to statistical dependence: Copula information"},{"categories":null,"contents":"","permalink":"https://rcalsaverini.github.io/publications/2008-intersubband-copy/","tags":null,"title":"Intersubband-induced spin-orbit interaction in quantum wells"},{"categories":null,"contents":"","permalink":"https://rcalsaverini.github.io/publications/2007-masters/","tags":null,"title":"Acoplamento spin-órbita inter-subbanda em heteroestruturas semicondutoras"}]